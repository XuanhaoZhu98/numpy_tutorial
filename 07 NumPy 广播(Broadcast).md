# 07 NumPy 广播(Broadcast)

NumPy 中的广播机制（Broadcast）旨在解决不同形状数组之间的算术运算问题。

## 一维数组与一维数组

如果进行运算的两个数组形状完全相同，即满足 a.shape == b.shape，那么 a*b 的结果就是 a 与 b 数组对应位相乘。示例如下：

```python
import numpy as np
a = np.array([0.1,0.2,0.3,0.4])
b = np.array([10,20,30,40])
c = a * b
print(c)
```

输出结果如下：

```
[ 1.  4.  9. 16.]
```

## 一维数组和多维数组

但如果两个形状不同的数组呢？它们之间就不能做算术运算了吗？当然不是！为了保持数组形状相同，NumPy 会自动触发一种**广播机制**，这种机制的核心是对形状较小的数组，在横向或纵向上进行一定次数的重复，使其与形状较大的数组拥有相同的维度。示例如下：

```python
import numpy as np
a = np.array([[ 0, 0, 0],
           [10,10,10],
           [20,20,20],
           [30,30,30]])
#b数组与a数组形状不同
b = np.array([1,2,3])
print(a + b)
```

输出结果为：

```
[[ 1  2  3]
 [11 12 13]
 [21 22 23]
 [31 32 33]]
```

图 1 ：通过数组 a 、b 的运算展示了广播机制的实现流程。

![](https://raw.githubusercontent.com/XuanhaoZhu98/image_hosting/main/img/202204211217404.gif)

图1：Numpy 数组广播机制

4x3 的二维 a 数组 与 1x3 的一维 b 数组相加，本质上可以理解为 b 数组在纵向上向下拓展 3 次（将第一行重复 3 次），从而生成与 a 数组相同形状的数组，之后再与 a 数组进行运算。

## 多维数组和多维数组

```python
c =np.array([[4],[5],[6]])
e = np.array([[1,2,3], [4,5,6],[7,8,9]])
print(c * e)
```

输出结果：

```
[[ 4  8 12]
 [20 25 30]
 [42 48 54]]
```

同理，我们可以得到三维数组的广播情况：

```python
import numpy as np
a = np.arange(1,25).reshape((3, 4, 2))
b = np.arange(1,9).reshape((4, 2))
print(a + b)
```

输出结果：

```
[[[ 2  4]
  [ 6  8]
  [10 12]
  [14 16]]

 [[10 12]
  [14 16]
  [18 20]
  [22 24]]

 [[18 20]
  [22 24]
  [26 28]
  [30 32]]]
```

图 2 ：三维数组广播机制的实现流程。

![](https://raw.githubusercontent.com/XuanhaoZhu98/image_hosting/main/img/202204211235944.png)

再来说一个易错的案例：

```python
arr = np.random.randn(4, 3)
print(arr)
r = arr - arr.mean(1)
```

结果报错：

```python
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Input In [94], in <cell line: 1>()
----> 1 r = arr - arr.mean(1)

ValueError: operands could not be broadcast together with shapes (4,3) (4,) 
```

因为arr.mean(1)产生的shape为(4,)，根据广播原则，较小的数组的后缘维度必须为1，所以需要使用reshape将arr.mean变成(4,1)

```python
arr = np.random.randn(4, 3)
print(arr)
r = arr - arr.mean(1).reshape((4,1))
print(r)
```

输出结果：

```
[[-0.36686188 -0.20733237  0.44416788]
 [ 1.5685736  -2.68261944 -1.62330594]
 [ 1.2405297   0.5639178  -0.69531588]
 [ 0.88659937 -0.26556549 -0.10679832]]
[[-0.32351976 -0.16399025  0.48751001]
 [ 2.48102419 -1.77016885 -0.71085535]
 [ 0.87081916  0.19420726 -1.06502642]
 [ 0.71518752 -0.43697734 -0.27821017]]
```

## 广播的规则

- 让所有输入数组都向其中维度最高的数组看齐，维度不足的部分都通过加 1 升维。
- 输出数组的形状是输入数组形状的各个维度上的最大值。
- 如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。
- 当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。

简单理解：对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足：

- 数组拥有相同形状。
- 当前维度的值相等。
- 当前维度的值有一个是 1。

若条件不满足，抛出 **"ValueError: frames are not aligned"** 异常。