# 17 NumPy 副本和视图

对 NumPy 数组执行些函数操作时，其中一部分函数会返回数组的副本，而另一部分函数则返回数组的视图。本节对数组的副本和视图做重点讲解。

## 浅拷贝和深拷贝区别

浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存（分支）。

1. 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。

2. 如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。

   <img src="https://raw.githubusercontent.com/XuanhaoZhu98/image_hosting/main/img/202204222332787.jpg" style="zoom: 33%;" />

深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象，是“值”而不是“引用”（不是分支）

1. 拷贝第一层级的对象属性或数组元素

2. 递归拷贝所有层级的对象属性和数组元素

3. 深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。

   <img src="https://raw.githubusercontent.com/XuanhaoZhu98/image_hosting/main/img/202204222332786.jpg" style="zoom: 33%;" />

其实从内存角度来说，副本就是对原数组进行深拷贝，新产生的副本与原数组具有不同的存储位置。而视图可理解为对数组的引用，它和原数组有着相同的内存位置。

视图一般发生在：

- numpy 的切片操作返回原数据的视图。
- 调用 ndarray 的 view() 函数产生一个视图。

副本一般发生在：

- Python 序列的切片操作，调用deepCopy()函数。
- 调用 ndarray 的 copy() 函数产生一个副本。

## 无复制/赋值操作

简单的赋值不会创建数组对象的副本。 相反，它使用原始数组的相同id()来访问它。 **id()返回 Python 对象的通用标识符**，类似于 C 中的指针。此外，一个数组的任何变化都反映在另一个数组上。 例如，一个数组的形状改变也会改变另一个数组的形状：

```python
import numpy as np 
a = np.array([[1,2,3,4],[9,0,2,3],[1,2,3,19]]) 
print(a) 
#a数组的ID
print(id(a)) 
b = a
#打印b数组
print(b)
#数组b的id
print(id(b)) 
b.shape = 4,3; 
#b数组形状的更改也会反映到a数组上
print(a)  
#查看a和b的关系
print(b is a)
print(b.base is a)
#判断是否拥有数据
print(a.flags.owndata)
print(b.flags.owndata)
```

输出结果：

```
[[ 1  2  3  4]
 [ 9  0  2  3]
 [ 1  2  3 19]]
2413498599920

[[ 1  2  3  4]
 [ 9  0  2  3]
 [ 1  2  3 19]]
2413498599920

[[ 1  2  3]
 [ 4  9  0]
 [ 2  3  1]
 [ 2  3 19]]
 
True
False

True
True
```

可以看出简单的赋值不会创建数组对象或其数据的拷贝，a和b是完全相同的

## 视图或浅拷贝

### 1) ndarray.view()

ndarray.view() 会创建一个共享原数组数据的新的数组对象。如果数组b是数组a的视图(view)，则称a为b的base(除非a也是视图)。视图数组中的数据实际上保存在base数组中。下面看一组示例：

```python
import numpy as np 
a = np.array([[1,2,3,4],[9,0,2,3],[1,2,3,19]]) 
print(a) 
#数组a的ID
print(id(a)) 
b = a.view() 
#打印b数组
print(b) 
#数组b的ID
print(id(b)) 
#改变b数组形状
b.shape = 4,3
print(a) 
print(b) 
#改变b数组值
b[2,1] = 99
print(a) 
print(b) 
#查看a和b的关系
print(b is a)
print(b.base is a)
#判断是否拥有数据
print(a.flags.owndata)
print(b.flags.owndata)
```

输出结果：

```
[[ 1  2  3  4]
 [ 9  0  2  3]
 [ 1  2  3 19]]
2413507987376

[[ 1  2  3  4]
 [ 9  0  2  3]
 [ 1  2  3 19]]
2413507985744

[[ 1  2  3  4]
 [ 9  0  2  3]
 [ 1  2  3 19]]
 
[[ 1  2  3]
 [ 4  9  0]
 [ 2  3  1]
 [ 2  3 19]]
 
[[ 1  2  3  4]
 [ 9  0  2 99]
 [ 1  2  3 19]]
 
[[ 1  2  3]
 [ 4  9  0]
 [ 2 99  1]
 [ 2  3 19]]
 
False
True

True
False
```

可以看到，与前一种情况不同，新数组的维数更改不会更改原始数据的维数，但是新数组数据更改后，也会影响原始数据。这说明不同的数组对象可以共享相同的数据，浅拷贝只是对另外一个变量的**内存地址**的拷贝，这两个变量指向同一个内存地址的变量值。

### 2) 切片创建视图

使用切片可以创建视图数组，若要修改视图的就会影响到原数组，示例如下：

```python
import numpy as np
arr = np.arange(10)
print (arr)
#创建切片修改原数组arr
a=arr[3:]
b=arr[3:]
a[1]=123
b[2]=234
print(arr)
print(id(a),id(b),id(arr[3:]))
#查看两个切片之间的关系
print(a is b)
#查看切片和原数组的关系
print(a.base is arr)
#判断是否拥有数据
print(a.flags.owndata)
```

输出结果：

```
[0 1 2 3 4 5 6 7 8 9]

[  0   1   2   3 123 234   6   7   8   9]

2413476353968 2413507985744 2413507988624

False

True

False
```

变量 a,b 都是 arr 的一部分视图，对视图的修改会直接反映到原数据中。但是我们观察 a,b 的 id，他们是不同的，也就是说，视图虽然指向原数据，但是他们和赋值引用还是有区别的。

## 副本或深拷贝 ndarray.copy()

该方法返回原数组的副本，对副本的修改不会影响到原数组，它们物理内存不在同一位置。示例如下：

```python
import numpy as np 
a = np.array([[1,2,3,4],[9,0,2,3],[1,2,3,19]]) 
print(a) 
#a数组ID
print(id(a)) 
b = a.copy() 
#打印经过copy方法的b数组
print(b) 
#b数组ID
print(id(b)) 
#改变b数组形状
b.shape=4,3
print(a) 
print(b) 
#改变b数组值
b[2,1] = 99
print(a) 
print(b) 
#查看a和b的关系
print(b is a)
print(b.base is a)
#判断是否拥有数据
print(a.flags.owndata)
print(b.flags.owndata)
```

输出结果:

```
[[ 1  2  3  4]
 [ 9  0  2  3]
 [ 1  2  3 19]]
2413507613200

[[ 1  2  3  4]
 [ 9  0  2  3]
 [ 1  2  3 19]]
2413499035056

[[ 1  2  3  4]
 [ 9  0  2  3]
 [ 1  2  3 19]]
 
[[ 1  2  3]
 [ 4  9  0]
 [ 2  3  1]
 [ 2  3 19]]
 
[[ 1  2  3  4]
 [ 9  0  2  3]
 [ 1  2  3 19]]
 
[[ 1  2  3]
 [ 4  9  0]
 [ 2 99  1]
 [ 2  3 19]]
 
False
False

True
True
```

可以看到copy方法生成数组及其数据的完整拷贝。深拷贝会开辟新的内存空间进行存储，两个变量指向的内存地址不同，拷贝完后，变量之间值的改变互不影响。